"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@medusajs/framework/utils");
const _models_1 = require("../models");
const _types_1 = require("../types");
const build_config_1 = require("../utils/build-config");
const default_schema_1 = require("../utils/default-schema");
const gql_to_types_1 = require("../utils/gql-to-types");
const index_metadata_status_1 = require("../utils/index-metadata-status");
class IndexModuleService extends utils_1.ModulesSdkUtils.MedusaService({
    IndexMetadata: _models_1.IndexMetadata,
}) {
    constructor(container, moduleDeclaration) {
        super(...arguments);
        this.moduleDeclaration = moduleDeclaration;
        this.__hooks = {
            onApplicationStart() {
                return this.onApplicationStart_();
            },
        };
        this.container_ = container;
        this.moduleOptions_ = (moduleDeclaration.options ??
            moduleDeclaration);
        const { [utils_1.Modules.EVENT_BUS]: eventBusModuleService, indexMetadataService, storageProviderCtr, storageProviderCtrOptions, } = container;
        this.eventBusModuleService_ = eventBusModuleService;
        this.storageProviderCtr_ = storageProviderCtr;
        this.storageProviderCtrOptions_ = storageProviderCtrOptions;
        this.indexMetadataService_ = indexMetadataService;
        if (!this.eventBusModuleService_) {
            throw new Error("EventBusModuleService is required for the IndexModule to work");
        }
    }
    async onApplicationStart_() {
        try {
            this.buildSchemaObjectRepresentation_();
            this.storageProvider_ = new this.storageProviderCtr_(this.container_, Object.assign(this.storageProviderCtrOptions_ ?? {}, {
                schemaObjectRepresentation: this.schemaObjectRepresentation_,
                entityMap: this.schemaEntitiesMap_,
            }), this.moduleOptions_);
            this.registerListeners();
            if (this.storageProvider_.onApplicationStart) {
                await this.storageProvider_.onApplicationStart();
            }
            await (0, gql_to_types_1.gqlSchemaToTypes)(this.moduleOptions_.schema ?? default_schema_1.defaultSchema);
            const fullSyncRequired = await this.syncIndexConfig();
            if (fullSyncRequired.length > 0) {
                await this.syncEntities(fullSyncRequired);
            }
        }
        catch (e) {
            console.log(e);
        }
    }
    async syncIndexConfig() {
        const schemaObjectRepresentation = (this.schemaObjectRepresentation_ ??
            {});
        const currentConfig = await this.indexMetadataService_.list();
        const currentConfigMap = new Map(currentConfig.map((c) => [c.entity, c]));
        const entityPresent = new Set();
        const newConfig = [];
        const updatedConfig = [];
        const deletedConfig = [];
        for (const [entityName, schemaEntityObjectRepresentation] of Object.entries(schemaObjectRepresentation)) {
            if (_types_1.schemaObjectRepresentationPropertiesToOmit.includes(entityName)) {
                continue;
            }
            const entity = schemaEntityObjectRepresentation.entity;
            const fields = schemaEntityObjectRepresentation.fields.sort().join(",");
            const fields_hash = (0, utils_1.simpleHash)(fields);
            const existingEntityConfig = currentConfigMap.get(entity);
            entityPresent.add(entity);
            if (!existingEntityConfig ||
                existingEntityConfig.fields_hash !== fields_hash) {
                const meta = {
                    id: existingEntityConfig?.id,
                    entity,
                    fields,
                    fields_hash,
                };
                if (!existingEntityConfig) {
                    newConfig.push(meta);
                }
                else {
                    updatedConfig.push({
                        ...meta,
                        status: index_metadata_status_1.IndexMetadataStatus.PENDING,
                    });
                }
            }
        }
        for (const [entity] of currentConfigMap) {
            if (!entityPresent.has(entity)) {
                deletedConfig.push({ entity });
            }
        }
        if (newConfig.length > 0) {
            await this.indexMetadataService_.create(newConfig);
        }
        if (updatedConfig.length > 0) {
            await this.indexMetadataService_.update(updatedConfig);
        }
        if (deletedConfig.length > 0) {
            await this.indexMetadataService_.delete(deletedConfig);
        }
        return await this.indexMetadataService_.list({
            status: [index_metadata_status_1.IndexMetadataStatus.PENDING, index_metadata_status_1.IndexMetadataStatus.PROCESSING],
        });
    }
    async syncEntities(entities) {
        const updatedStatus = async (entity, status) => {
            await this.indexMetadataService_.update({
                data: {
                    status,
                },
                selector: {
                    entity,
                },
            });
        };
        for (const entity of entities) {
            await updatedStatus(entity.entity, index_metadata_status_1.IndexMetadataStatus.PROCESSING);
            try {
                // await this.syncEntity(entity)
                await updatedStatus(entity.entity, index_metadata_status_1.IndexMetadataStatus.DONE);
            }
            catch (e) {
                await updatedStatus(entity.entity, index_metadata_status_1.IndexMetadataStatus.ERROR);
            }
        }
    }
    async query(config) {
        return await this.storageProvider_.query(config);
    }
    registerListeners() {
        const schemaObjectRepresentation = (this.schemaObjectRepresentation_ ??
            {});
        for (const [entityName, schemaEntityObjectRepresentation] of Object.entries(schemaObjectRepresentation)) {
            if (_types_1.schemaObjectRepresentationPropertiesToOmit.includes(entityName)) {
                continue;
            }
            ;
            schemaEntityObjectRepresentation.listeners.forEach((listener) => {
                this.eventBusModuleService_.subscribe(listener, this.storageProvider_.consumeEvent(schemaEntityObjectRepresentation));
            });
        }
    }
    buildSchemaObjectRepresentation_() {
        if (this.schemaObjectRepresentation_) {
            return this.schemaObjectRepresentation_;
        }
        const [objectRepresentation, entityMap] = (0, build_config_1.buildSchemaObjectRepresentation)(this.moduleOptions_.schema ?? default_schema_1.defaultSchema);
        this.schemaObjectRepresentation_ = objectRepresentation;
        this.schemaEntitiesMap_ = entityMap;
        return this.schemaObjectRepresentation_;
    }
}
exports.default = IndexModuleService;
//# sourceMappingURL=index-module-service.js.map