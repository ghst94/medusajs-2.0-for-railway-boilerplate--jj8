"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DataSynchronizer_storageProvider, _DataSynchronizer_schemaObjectRepresentation, _DataSynchronizer_query;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSynchronizer = void 0;
const utils_1 = require("@medusajs/framework/utils");
class DataSynchronizer {
    constructor({ storageProvider, schemaObjectRepresentation, query, }) {
        _DataSynchronizer_storageProvider.set(this, void 0);
        _DataSynchronizer_schemaObjectRepresentation.set(this, void 0);
        _DataSynchronizer_query.set(this, void 0);
        __classPrivateFieldSet(this, _DataSynchronizer_storageProvider, storageProvider, "f");
        __classPrivateFieldSet(this, _DataSynchronizer_schemaObjectRepresentation, schemaObjectRepresentation, "f");
        __classPrivateFieldSet(this, _DataSynchronizer_query, query, "f");
    }
    async sync({ entityName, pagination = {}, ack, }) {
        const schemaEntityObjectRepresentation = __classPrivateFieldGet(this, _DataSynchronizer_schemaObjectRepresentation, "f")[entityName];
        const { fields, alias, moduleConfig } = schemaEntityObjectRepresentation;
        const entityPrimaryKey = fields.find((field) => !!moduleConfig.linkableKeys?.[field]);
        if (!entityPrimaryKey) {
            void ack({
                lastCursor: pagination.cursor ?? null,
                err: new Error(`Entity ${entityName} does not have a linkable primary key`),
            });
            return;
        }
        let processed = 0;
        let currentCursor = pagination.cursor;
        const batchSize = pagination.batchSize ?? 1000;
        const limit = pagination.limit ?? Infinity;
        let done = false;
        let error = null;
        while (processed < limit || !done) {
            const filters = {};
            if (currentCursor) {
                filters[entityPrimaryKey] = { $gt: currentCursor };
            }
            if (pagination.updated_at) {
                filters["updated_at"] = { $gt: pagination.updated_at };
            }
            const { data } = await __classPrivateFieldGet(this, _DataSynchronizer_query, "f").graph({
                entity: alias,
                fields: [entityPrimaryKey],
                filters,
                pagination: {
                    order: {
                        [entityPrimaryKey]: "asc",
                    },
                    take: batchSize,
                },
            });
            done = !data.length;
            if (done) {
                break;
            }
            const envelop = {
                data,
                name: `*.${utils_1.CommonEvents.CREATED}`,
            };
            try {
                await __classPrivateFieldGet(this, _DataSynchronizer_storageProvider, "f").consumeEvent(schemaEntityObjectRepresentation)(envelop);
                currentCursor = data[data.length - 1][entityPrimaryKey];
                processed += data.length;
                void ack({ lastCursor: currentCursor });
            }
            catch (err) {
                error = err;
                break;
            }
        }
        let acknoledgement = {
            lastCursor: currentCursor,
            done: true,
        };
        if (error) {
            acknoledgement = {
                lastCursor: currentCursor,
                err: error,
            };
            void ack(acknoledgement);
            return acknoledgement;
        }
        void ack(acknoledgement);
        return acknoledgement;
    }
}
exports.DataSynchronizer = DataSynchronizer;
_DataSynchronizer_storageProvider = new WeakMap(), _DataSynchronizer_schemaObjectRepresentation = new WeakMap(), _DataSynchronizer_query = new WeakMap();
//# sourceMappingURL=data-synchronizer.js.map